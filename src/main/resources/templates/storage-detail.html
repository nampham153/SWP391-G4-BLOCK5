<!DOCTYPE html>
<html lang="vi" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Chi tiết kho</title>
    <link rel="stylesheet" th:href="@{/css/storage-detail.css}">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <style>
        /* Feedback-related CSS temporarily disabled to avoid nested comment lint */
        /* .feedback-section, .feedback-list-section { display: none; } */
        /* Minimal styles for zone tiles */
        .zone-tile { transition: all .15s ease; }
        .zone-tile:hover { box-shadow: 0 0 0 2px #16a34a33; }
        .zone-tile.selected { outline: 2px solid #16a34a; background: #16a34a0d; }
        /* 50m² unit tiles */
        .unit-tile { user-select: none; }
        .unit-tile.selected { background-color: #dcfce7; outline: 2px solid #16a34a; }
        .unit-tile.disabled { background-color: #f3f4f6; opacity: .6; pointer-events: none; text-decoration: line-through; }
    </style>
    <style>
        .unit-tile.disabled {
            opacity: 0.5;
            pointer-events: none;
            text-decoration: line-through;
        }
        .unit-tile.selected {
            background-color: #dcfce7; /* green-100 */
            border-color: #22c55e;     /* green-500 */
        }
    </style>
</head>

<body>
<!-- Navigation Bar -->
<div th:replace="~{taskbar/customer-navbar :: customerNavbar}"></div>

<div class="container">
    <!-- Hiển thị thông báo thành công -->
    <div th:if="${message}" class="alert alert-success">
        [[${message}]]
    </div>

    <!-- Hiển thị thông báo lỗi -->
    <div th:if="${error}" class="alert alert-error">
        [[${error}]]
    </div>

    <div class="detail-container">
        <!-- Storage Information Section -->
        <div class="info-section">
            <div class="storage-header">
                <div class="details-header">
                    <h1 class="storage-title" th:text="${storage.getStoragename()}"></h1>
                    <a href="/SWP/storages" class="back-btn-nav">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="m12 19-7-7 7-7"/>
                            <path d="M19 12H5"/>
                        </svg>
                        Quay lại
                    </a>
                </div>

                <div class="status-rating-container">
                    <div class="status-badge" th:class="${storage.isStatus()} ? 'status-badge available' : 'status-badge rented'">
                        <svg class="status-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path th:if="${storage.isStatus()}" d="M9 12l2 2 4-4"/>
                            <path th:unless="${storage.isStatus()}" d="M18 6L6 18"/>
                            <path th:unless="${storage.isStatus()}" d="M6 6l12 12"/>
                            <circle cx="12" cy="12" r="10"/>
                        </svg>
                        <span th:text="${storage.isStatus()} ? 'Còn trống' : 'Đang thuê'">Còn trống</span>
                    </div>

                    <div class="rating-container">
                        <div class="location">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
                                <circle cx="12" cy="10" r="3"/>
                            </svg>
                            <span th:text="|${storage.state}, ${storage.city}|"></span>
                        </div>
                    </div>
                </div>

                <div class="price-container">
                    <span class="price"
                          th:text="${storage.getPricePerDay() != null ? #numbers.formatDecimal(storage.getPricePerDay(), 0, 'POINT', 0, 'COMMA') : 0} + ' VND'"></span>
                    <span class="price-unit">/ngày</span>
                </div>
            </div>

            <!-- Storage Details Card -->
            <div class="info-card">
                <h3 class="card-title">Thông tin chi tiết</h3>
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-icon area-icon">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                            </svg>
                        </div>
                        <div class="info-content">
                            <label>Diện tích</label>
                            <span th:text="${storage.getArea()} + ' m²'"></span>
                        </div>
                    </div>

                    <div class="info-item">
                        <div class="info-icon id-icon">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                <polyline points="14,2 14,8 20,8"/>
                                <line x1="16" y1="13" x2="8" y2="13"/>
                                <line x1="16" y1="17" x2="8" y2="17"/>
                                <polyline points="10,9 9,9 8,9"/>
                            </svg>
                        </div>
                        <div class="info-content">
                            <label>Mã kho</label>
                            <span th:text="${storage.getStorageid()}"></span>
                        </div>
                    </div>
                </div>

                <div class="address-section">
                    <label>Địa chỉ đầy đủ</label>
                    <div class="address-content">
                        <p class="address-main" th:text="|${storage.address}, ${storage.state}, ${storage.city}|"></p>
                    </div>
                </div>
            </div>

            <!-- Description Card -->
            <div class="info-card">
                <h3 class="card-title">Mô tả</h3>
                <p class="description-text" th:text="${storage.getDescription()}">
                </p>
            </div>

            <div class="action-buttons flex gap-4 mt-4">
                <!-- Hiển thị nút đặt thuê khi kho còn trống -->
                <div th:if="${storage.isStatus()}">
                    <button type="button" class="booking-btn flex items-center gap-2" onclick="openModal()">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                            <line x1="16" y1="2" x2="16" y2="6"/>
                            <line x1="8" y1="2" x2="8" y2="6"/>
                            <line x1="3" y1="10" x2="21" y2="10"/>
                        </svg>
                        Đặt thuê ngay
                    </button>
                </div>

                <!-- Hiển thị thông báo khi kho đang được thuê -->
                <div th:unless="${storage.isStatus()}">
                    <div class="unavailable-notice flex items-center gap-2 bg-red-50 text-red-700 px-4 py-3 rounded-lg border border-red-200">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M15 9l-6 6"/>
                            <path d="M9 9l6 6"/>
                        </svg>
                        <span class="font-medium">Kho này hiện đang được thuê và không thể đặt thêm</span>
                    </div>
                </div>
            </div>

            <!-- Modal chọn ngày -->
            <div id="bookingModal" class="fixed inset-0 bg-gray-800 bg-opacity-50 flex items-center justify-center hidden z-50">
                <div class="bg-white rounded-lg p-6 w-full max-w-md">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold text-gray-800">Chọn ngày thuê</h3>
                        <button onclick="closeModal()" class="text-gray-500 hover:text-gray-700">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M18 6L6 18"/>
                                <path d="M6 6l12 12"/>
                            </svg>
                        </button>
                    </div>
                    <form th:action="@{/SWP/booking/{storageId}/booking(storageId=${storage.storageid})}" method="post" class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">Chọn ngày bắt đầu</label>
                            <input type="date" id="startDate" name="startDate" required
                                   class="w-full border border-gray-300 rounded px-3 py-2 focus:ring-green-500 focus:border-green-500">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-1 text-gray-700">Chọn ngày kết thúc</label>
                            <input type="date" id="endDate" name="endDate" required
                                   class="w-full border border-gray-300 rounded px-3 py-2 focus:ring-green-500 focus:border-green-500">
                        </div>
                        <div class="space-y-3">
                            <label class="block text-sm font-medium mb-1 text-gray-700">Chọn Zone</label>
                            <input type="hidden" id="zoneIdHidden" name="zoneId">
                            <input type="hidden" id="zoneIdsHidden" name="zoneIds">
                            <div id="zoneGrid" class="grid grid-cols-2 sm:grid-cols-3 gap-3">
                                <!-- Available zone -->
                                <div th:if="${z.status == null or (z.status != null and #strings.equalsIgnoreCase(z.status, 'AVAILABLE'))}"
                                     th:each="z : ${zones}"
                                     class="zone-tile cursor-pointer border rounded p-3 text-center select-none"
                                     th:attr="data-zone-id=${z.id},data-available=${z.status},data-name=${z.name != null ? z.name : 'Zone'},data-area=${z.zoneArea != null ? z.zoneArea : 0},data-price=${z.pricePerDay != null ? z.pricePerDay : 0}"
                                     onclick="selectZone(this)">
                                    <div class="font-semibold" th:text="${z.name != null ? z.name : 'Zone'}">Zone</div>
<!--                                    <div class="text-xs text-gray-600">-->
<!--                                        <span th:text="${(z.zoneArea != null ? z.zoneArea : 0)} + ' m²'"></span> •-->
<!--                                        <span th:text="${(z.pricePerDay != null ? #numbers.formatDecimal(z.pricePerDay, 0, 'POINT', 0, 'COMMA') : '0')} + ' VND/ngày'"></span>-->
<!--                                    </div>-->
                                    <div class="mt-1 text-xs">Còn trống</div>
                                </div>
                                <!-- Unavailable zone -->
                                <div th:unless="${z.status == null or (z.status != null and #strings.equalsIgnoreCase(z.status, 'AVAILABLE'))}"
                                     th:each="z : ${zones}"
                                     class="zone-tile cursor-pointer border rounded p-3 text-center select-none opacity-50 pointer-events-none line-through"
                                     th:attr="data-zone-id=${z.id},data-available=${z.status},data-name=${z.name != null ? z.name : 'Zone'},data-area=${z.zoneArea != null ? z.zoneArea : 0},data-price=${z.pricePerDay != null ? z.pricePerDay : 0}"
                                     onclick="selectZone(this)">
                                    <div class="font-semibold" th:text="${z.name != null ? z.name : 'Zone'}">Zone</div>
                                    <div class="text-xs text-gray-600">
                                        <span th:text="${(z.zoneArea != null ? z.zoneArea : 0)} + ' m²'"></span> •
                                        <span th:text="${(z.pricePerDay != null ? #numbers.formatDecimal(z.pricePerDay, 0, 'POINT', 0, 'COMMA') : '0')} + ' VND/ngày'"></span>
                                    </div>
                                    <div class="mt-1 text-xs">Đã thuê</div>
                                </div>
                            </div>

                            <div class="pt-2 border-t" th:if="${false}">
                                <div class="flex items-center justify-between mb-1">
                                    <label class="block text-sm font-medium text-gray-700">Chọn diện tích theo ô 50 m²</label>
                                    <div class="text-sm text-gray-600">
                                        Đã chọn: <span id="unitSelectedCount">0</span> ô (<span id="unitSelectedArea">0</span> m²)
                                    </div>
                                </div>
                                <input type="hidden" id="preSelectedArea" name="preSelectedArea" />
                                <input type="hidden" id="selectedUnitIndices" name="selectedUnitIndices" />
                                <div id="unitGrid" class="grid gap-2"></div>
                                <div class="text-xs text-gray-500 mt-1">Giữ chuột và kéo để chọn theo hình chữ nhật. Mỗi ô = 50 m².</div>
                            </div>
                        </div>
                        <div class="flex justify-end gap-2">
                            <button type="button" onclick="closeModal()"
                                    class="bg-gray-300 hover:bg-gray-400 text-gray-800 px-4 py-2 rounded font-semibold">
                                Hủy
                            </button>
                            <button type="submit"
                                    class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded font-semibold">
                                Tiếp tục
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Thông báo -->
    <div th:if="${message}" class="message success">
        <span th:text="${message}"></span>
    </div>
    <div th:if="${error}" class="message error">
        <span th:text="${error}"></span>
    </div>

    <!-- Nếu khách đủ điều kiện đánh giá -->
    <div th:if="${canFeedback}">
        <!-- Nếu chưa đánh giá -->
        <div th:if="${!hasFeedbacked}">
            <form th:action="@{/SWP/feedbacks/submit}" method="post" class="space-y-4">
                <input type="hidden" name="storageId" th:value="${storage.storageid}" />
                <div>
                    <label class="block text-sm font-medium mb-1">Nội dung</label>
                    <textarea name="content" rows="3" required
                              class="w-full border border-gray-300 rounded px-3 py-2 focus:ring-green-500 focus:border-green-500"
                              placeholder="Chia sẻ trải nghiệm của bạn..."></textarea>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-1">Số sao</label>
                    <select name="rating" required class="border border-gray-300 rounded px-3 py-2">
                        <option value="" disabled selected>-- Chọn --</option>
                        <option th:each="i : ${#numbers.sequence(1,5)}"
                                th:value="${i}"
                                th:text="${i} + ' sao'"></option>
                    </select>
                </div>
                <button type="submit"
                        class="bg-green-600 hover:bg-green-700 text-white px-5 py-2 rounded font-semibold">
                    Gửi đánh giá
                </button>
            </form>
        </div>
        <!-- Nếu đã đánh giá -->
        <div th:if="${hasFeedbacked}" class="feedbacked-message">
            Bạn đã gửi đánh giá cho kho này. Xin cảm ơn!
        </div>
    </div>

    
</div>
<!-- Footer -->
<div th:replace="~{taskbar/customer-footer :: customerFooter}"></div>

<!-- Scripts -->
<script th:inline="javascript">
    // Global variables and functions for modal access
    let startInput, endInput, storageId, unitGrid, totalUnits;
    const UNIT_SIZE = 50;
    
    // Global apply unavailable function for 50m² units
    function applyUnavailable(indices) {
        // Check if unitGrid exists
        if (!unitGrid || !unitGrid.children) {
            console.debug('[Grid] unitGrid not available, skipping apply unavailable');
            return;
        }
        
        const raw = Array.isArray(indices) ? indices.slice() : [];
        // Tự nhận biết dữ liệu 1-based: tất cả >=1, không có 0, và max <= totalUnits
        let normalized = raw;
        if (raw.length > 0) {
            const minIdx = Math.min(...raw);
            const maxIdx = Math.max(...raw);
            const assumeOneBased = minIdx >= 1 && !raw.includes(0) && maxIdx <= totalUnits;
            if (assumeOneBased) {
                normalized = raw.map(i => i - 1);
                console.debug('[Grid] Converted 1-based -> 0-based:', raw, '=>', normalized);
            }
        }
        // Loại bỏ index ngoài phạm vi grid
        normalized = normalized.filter(i => Number.isInteger(i) && i >= 0 && i < totalUnits);
        const set = new Set(normalized);
        Array.from(unitGrid.children).forEach(ch => {
            const idx = parseInt(ch.dataset.index);
            if (set.has(idx)) {
                ch.classList.add('disabled');
                ch.classList.remove('selected');
            } else {
                ch.classList.remove('disabled');
            }
        });
        console.debug('[Grid] Applied unavailable indices:', Array.from(set));
        if (typeof updateUnitSelectionCount === 'function') {
            updateUnitSelectionCount();
        }
    }
    
    // Global refresh functions
    async function refreshUnavailable() {
        const s = toIsoDateStr(startInput);
        const e = toIsoDateStr(endInput);
        if (!s || !e) return;
        try {
            const res = await fetch(`/SWP/booking/${storageId}/unavailable?startDate=${startInput.value}&endDate=${endInput.value}`);
            if (!res.ok) {
                throw new Error('Network error');
            }
            const data = await res.json();
            console.debug('[Fetch] Unavailable data:', data);
            applyUnavailable(Array.isArray(data) ? data : []);
        } catch (err) {
            // On error, clear unavailable markers
            console.error('[Fetch] Unavailable failed:', err);
            applyUnavailable([]);
        }
    }

    // Global refresh unavailable zones function
    async function refreshUnavailableZones() {
        const startDate = startInput.value;
        const endDate = endInput.value;
        console.log('[Debug] refreshUnavailableZones called with:', { startDate, endDate });
        
        if (!startDate || !endDate) {
            console.log('[Debug] Missing dates, skipping zone check');
            return;
        }
        
        try {
            const url = `/SWP/booking/${storageId}/unavailable-zones?startDate=${startDate}&endDate=${endDate}`;
            console.log('[Debug] Fetching unavailable zones from:', url);
            
            const res = await fetch(url);
            if (!res.ok) {
                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            }
            const data = await res.json();
            console.log('[Debug] Unavailable zones response:', data);
            applyUnavailableZones(Array.isArray(data) ? data : []);
        } catch (err) {
            // On error, clear unavailable markers
            console.error('[Error] Unavailable zones failed:', err);
            applyUnavailableZones([]);
        }
    }

    // Global apply unavailable zones function
    function applyUnavailableZones(unavailableZoneIds) {
        console.log('[Debug] applyUnavailableZones called with:', unavailableZoneIds);
        const zoneTiles = document.querySelectorAll('.zone-tile');
        console.log('[Debug] Found zone tiles:', zoneTiles.length);
        
        zoneTiles.forEach((tile, index) => {
            const zoneId = parseInt(tile.getAttribute('data-zone-id'));
            console.log(`[Debug] Processing tile ${index}: zoneId=${zoneId}, unavailable=${unavailableZoneIds.includes(zoneId)}`);
            
            if (unavailableZoneIds.includes(zoneId)) {
                console.log(`[Debug] Marking zone ${zoneId} as unavailable`);
                tile.classList.add('zone-unavailable');
                tile.style.pointerEvents = 'none';
                tile.style.opacity = '0.5';
                tile.style.backgroundColor = '#f3f4f6';
                tile.style.color = '#6b7280';
                const statusDiv = tile.querySelector('.mt-1.text-xs');
                if (statusDiv) {
                    statusDiv.textContent = 'Đã thuê';
                }
            } else {
                console.log(`[Debug] Marking zone ${zoneId} as available`);
                tile.classList.remove('zone-unavailable');
                tile.style.pointerEvents = '';
                tile.style.opacity = '';
                tile.style.backgroundColor = '';
                tile.style.color = '';
                const statusDiv = tile.querySelector('.mt-1.text-xs');
                if (statusDiv) {
                    statusDiv.textContent = 'Còn trống';
                }
            }
        });
    }

    // Validation và điều chỉnh thuê theo tháng
    function validateAndAdjustMonthlyRental() {
        const startInput = document.getElementById('startDate');
        const endInput = document.getElementById('endDate');
        
        if (!startInput || !endInput || !startInput.value || !endInput.value) {
            return;
        }
        
        const startDate = new Date(startInput.value);
        const endDate = new Date(endInput.value);
        
        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
            return;
        }
        
        // Điều chỉnh ngày bắt đầu về đầu tháng
        const adjustedStartDate = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
        
        // Điều chỉnh ngày kết thúc về cuối tháng
        const adjustedEndDate = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0);
        
        let hasAdjustment = false;
        let warningMessage = '';
        
        // Bỏ validation ngày bắt đầu - cho phép người dùng chọn bất kỳ ngày nào
        
        // Kiểm tra và điều chỉnh ngày kết thúc về ngày cuối cùng của tháng
        // Sử dụng cách tính ngày cuối tháng chính xác
        const correctEndDate = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 1);
        const lastDayOfMonth = correctEndDate.getDate();
        
        if (endDate.getDate() !== lastDayOfMonth) {
            hasAdjustment = true;
            const adjustedEndStr = correctEndDate.toISOString().split('T')[0];
            endInput.value = adjustedEndStr;
            // Lấy ngày thực tế từ ngày đã điều chỉnh để đảm bảo chính xác
            const actualDay = correctEndDate.getDate();
            warningMessage += `Ngày kết thúc đã được điều chỉnh về cuối tháng: ${adjustedEndStr} .`;
        }
        
        // Hiển thị cảnh báo nếu có điều chỉnh
        if (hasAdjustment) {
            console.log('[Debug] Monthly rental adjustment:', warningMessage);
            
            // Hiển thị thông báo cho người dùng chỉ khi có điều chỉnh ngày kết thúc
            const existingAlert = document.getElementById('monthlyRentalAlert');
            if (existingAlert) {
                existingAlert.remove();
            }
            
            const alertDiv = document.createElement('div');
            alertDiv.id = 'monthlyRentalAlert';
            alertDiv.className = 'bg-yellow-100 border border-yellow-400 text-yellow-700 px-4 py-3 rounded mb-4';
            alertDiv.innerHTML = `
                <strong>Thông báo:</strong> ${warningMessage}
                <br><small>Ngày kết thúc đã được tự động điều chỉnh về cuối tháng.</small>
            `;
            
            const modal = document.getElementById('bookingModal');
            const form = modal.querySelector('form');
            if (form) {
                form.insertBefore(alertDiv, form.firstChild);
            }
            
            // Refresh lại dữ liệu sau khi điều chỉnh ngày
            setTimeout(() => {
                console.log('[Debug] Refreshing data after monthly adjustment...');
                refreshUnavailable();
                refreshUnavailableZones();
                calculateEstimatedCost();
            }, 200);
        }
    }

    // Helper function for date conversion
    function toIsoDateStr(inputEl) {
        // Ưu tiên valueAsDate nếu có, fallback parse thủ công
        const d = inputEl.valueAsDate;
        if (d instanceof Date && !isNaN(d)) {
            const y = d.getFullYear();
            const mth = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return y + '-' + mth + '-' + day;
        }
        // Fallback: cố gắng parse các định dạng phổ biến
        const raw = (inputEl.value || '').trim();
        if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) return raw; // ISO ok
        const m = raw.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/); // MM/DD/YYYY
        if (m) {
            const mm = m[1].padStart(2, '0');
            const dd = m[2].padStart(2, '0');
            const yyyy = m[3];
            return yyyy + '-' + mm + '-' + dd;
        }
        // Không parse được => trả về chuỗi rỗng để tránh gọi API sai
        return '';
    }

    document.addEventListener('DOMContentLoaded', function () {
        const today = new Date().toISOString().split('T')[0];
        startInput = document.getElementById('startDate');
        endInput = document.getElementById('endDate');
        storageId = /*[[${storage.storageid}]]*/ 0;
        
        // Initialize unit grid variables
        const UNIT_SIZE = 50;
        const storageArea = /*[[${storage.area}]]*/ 0;
        totalUnits = Math.max(0, Math.floor(storageArea / UNIT_SIZE));
        unitGrid = document.getElementById('unitGrid');

        // Đặt giá trị tối thiểu cho ngày bắt đầu và ngày kết thúc
        startInput.setAttribute('min', today);
        endInput.setAttribute('min', today);

        // Cập nhật ngày tối thiểu của ngày kết thúc khi ngày bắt đầu thay đổi
        startInput.addEventListener('change', function () {
            endInput.setAttribute('min', startInput.value);
            // Gọi validation thuê theo tháng và refresh zone
            validateAndAdjustMonthlyRental();
        });

        // Thêm event listener cho endInput để gọi validation khi thay đổi
        endInput.addEventListener('change', function () {
            // Gọi validation thuê theo tháng và refresh zone
            validateAndAdjustMonthlyRental();
        });

        // Build 50 m² unit grid once on load
        if (unitGrid && totalUnits > 0) {
            const cols = Math.max(1, Math.ceil(Math.sqrt(totalUnits))); // near-square
            unitGrid.style.gridTemplateColumns = 'repeat(' + cols + ', minmax(0, 1fr))';

            // Create tiles
            for (let i = 0; i < totalUnits; i++) {
                const tile = document.createElement('div');
                tile.className = 'unit-tile border rounded h-10 flex items-center justify-center text-xs cursor-pointer select-none';
                tile.textContent = UNIT_SIZE + ' m²';
                tile.dataset.index = String(i);
                unitGrid.appendChild(tile);
            }

            // Helper: apply unavailable index list to grid
            function applyUnavailable(indices) {
                const raw = Array.isArray(indices) ? indices.slice() : [];
                // Tự nhận biết dữ liệu 1-based: tất cả >=1, không có 0, và max <= totalUnits
                let normalized = raw;
                if (raw.length > 0) {
                    const minIdx = Math.min(...raw);
                    const maxIdx = Math.max(...raw);
                    const assumeOneBased = minIdx >= 1 && !raw.includes(0) && maxIdx <= totalUnits;
                    if (assumeOneBased) {
                        normalized = raw.map(i => i - 1);
                        console.debug('[Grid] Converted 1-based -> 0-based:', raw, '=>', normalized);
                    }
                }
                // Loại bỏ index ngoài phạm vi grid
                normalized = normalized.filter(i => Number.isInteger(i) && i >= 0 && i < totalUnits);
                const set = new Set(normalized);
                Array.from(unitGrid.children).forEach(ch => {
                    const idx = parseInt(ch.dataset.index);
                    if (set.has(idx)) {
                        ch.classList.add('disabled');
                        ch.classList.remove('selected');
                    } else {
                        ch.classList.remove('disabled');
                    }
                });
                console.debug('[Grid] Applied unavailable indices:', Array.from(set));
                updateUnitSelectionCount();
            }

            // Drag-to-select rectangle
            let isDragging = false;
            let isMouseDown = false;
            let startIndex = null;
            let lastDownTile = null;

            function indexToRC(idx) {
                const r = Math.floor(idx / cols);
                const c = idx % cols;
                return { r, c };
            }
            function updateSelectionRect(endIdx) {
                const s = indexToRC(startIndex);
                const e = indexToRC(endIdx);
                const r1 = Math.min(s.r, e.r), r2 = Math.max(s.r, e.r);
                const c1 = Math.min(s.c, e.c), c2 = Math.max(s.c, e.c);
                const children = unitGrid.children;
                for (let i = 0; i < children.length; i++) {
                    const { r, c } = indexToRC(i);
                    if (r >= r1 && r <= r2 && c >= c1 && c <= c2) {
                        children[i].classList.add('selected');
                    } else if (!isDragging) {
                        // do nothing on finalize here
                    } else {
                        // while dragging, clear others for preview
                        children[i].classList.remove('selected');
                    }
                }
                updateUnitSelectionCount();
            }

            unitGrid.addEventListener('mousedown', (e) => {
                const tile = e.target.closest('.unit-tile');
                if (!tile) return;
                if (tile.classList.contains('disabled')) return; // block interaction on disabled
                isMouseDown = true;
                startIndex = parseInt(tile.dataset.index);
                lastDownTile = tile;
                // Do not mark dragging or select yet; wait for movement or click handler
            });
            unitGrid.addEventListener('mouseover', (e) => {
                if (!isMouseDown) return;
                const tile = e.target.closest('.unit-tile');
                if (!tile) return;
                if (tile.classList.contains('disabled')) return; // ignore drag over disabled
                const idx = parseInt(tile.dataset.index);
                if (!isDragging && idx !== startIndex) {
                    isDragging = true; // start drag only when moving to another tile
                    // Clear previous selection only when drag begins (so clicks can accumulate)
                    Array.from(unitGrid.children).forEach(ch => ch.classList.remove('selected'));
                }
                updateSelectionRect(idx);
            });
            document.addEventListener('mouseup', (e) => {
                // If mouse was pressed on a tile and no drag happened => treat as simple click toggle
                if (isMouseDown && !isDragging && lastDownTile) {
                    if (!lastDownTile.classList.contains('disabled')) {
                        lastDownTile.classList.toggle('selected');
                    }
                    updateUnitSelectionCount();
                }
                isMouseDown = false;
                isDragging = false;
                lastDownTile = null;
            });

            function updateUnitSelectionCount() {
                const selectedTiles = unitGrid.querySelectorAll('.unit-tile.selected');
                const count = selectedTiles.length;
                const area = count * UNIT_SIZE;
                const cntEl = document.getElementById('unitSelectedCount');
                const areaEl = document.getElementById('unitSelectedArea');
                const hiddenArea = document.getElementById('preSelectedArea');
                const hiddenIndices = document.getElementById('selectedUnitIndices');
                if (cntEl) cntEl.textContent = String(count);
                if (areaEl) areaEl.textContent = String(area);
                if (hiddenArea) hiddenArea.value = String(area);
                if (hiddenIndices) {
                    const indices = Array.from(selectedTiles).map(t => t.dataset.index).join(',');
                    hiddenIndices.value = indices;
                }
                // If user selected tiles, clear zone selection to avoid conflicts
                if (area > 0) {
                    const zoneHidden = document.getElementById('zoneIdHidden');
                    if (zoneHidden) zoneHidden.value = '';
                    document.querySelectorAll('#zoneGrid .zone-tile.selected').forEach(el => el.classList.remove('selected'));
                }
                calculateEstimatedCost();
            }

            function calculateEstimatedCost() {
                const startInput = document.getElementById('startDate');
                const endInput = document.getElementById('endDate');
                
                if (!startInput || !endInput || !startInput.value || !endInput.value) {
                    return;
                }
                
                const startDate = new Date(startInput.value);
                const endDate = new Date(endInput.value);
                
                if (endDate <= startDate) {
                    return;
                }
                
                // Chuẩn hóa ngày kết thúc về cuối tháng
                const normalizedEndDate = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0);
                
                // Tính số tháng thuê
                const monthsDiff = (normalizedEndDate.getFullYear() - startDate.getFullYear()) * 12 + 
                                  (normalizedEndDate.getMonth() - startDate.getMonth()) + 1;
                const monthsCount = Math.max(1, monthsDiff);
                
                let totalCost = 0;
                
                // Tính theo zone đã chọn - Công thức mới: Đơn giá 1 zone/tháng × Số zone × Số tháng
                const selectedZoneElements = document.querySelectorAll('.zone-tile.selected');
                if (selectedZoneElements.length > 0) {
                    // Lấy giá từ zone đầu tiên đã chọn
                    // Note: pricePerDay trong DB thực chất là giá/tháng
                    const firstZoneElement = selectedZoneElements[0];
                    const firstZonePricePerMonth = parseFloat(firstZoneElement.dataset.pricePerDay || 0);
                    const zoneCount = selectedZoneElements.length;
                    totalCost = firstZonePricePerMonth * zoneCount * monthsCount;
                } else {
                    // Fallback: tính theo diện tích storage
                    // Note: pricePerDay trong DB thực chất là giá/tháng
                    const storagePricePerMonth = /*[[${storage.pricePerDay}]]*/ 0;
                    totalCost = monthsCount * storagePricePerMonth;
                }
                
                // Hiển thị kết quả
                const costDisplay = document.getElementById('estimatedCost');
                if (costDisplay) {
                    costDisplay.textContent = totalCost.toLocaleString('vi-VN') + ' VNĐ (' + monthsCount + ' tháng)';
                }
            }

            // Initial load
            refreshUnavailable();
            refreshUnavailableZones();
        }
    });

    // Hàm mở modal
    function openModal() {
        const modal = document.getElementById('bookingModal');
        modal.classList.remove('hidden');
        // Prefill default dates if empty: today and tomorrow
        const startInput = document.getElementById('startDate');
        const endInput = document.getElementById('endDate');
        if (startInput && endInput) {
            const today = new Date();
            const yyyy = today.getFullYear();
            const mm = String(today.getMonth() + 1).padStart(2, '0');
            const dd = String(today.getDate()).padStart(2, '0');
            const todayStr = yyyy + '-' + mm + '-' + dd;

            const tomorrow = new Date(today.getTime() + 24*60*60*1000);
            const yyyy2 = tomorrow.getFullYear();
            const mm2 = String(tomorrow.getMonth() + 1).padStart(2, '0');
            const dd2 = String(tomorrow.getDate()).padStart(2, '0');
            const tomorrowStr = yyyy2 + '-' + mm2 + '-' + dd2;

            if (!startInput.value) startInput.value = todayStr;
            // Ensure end > start
            if (!endInput.value || new Date(endInput.value) <= new Date(startInput.value)) {
                endInput.value = tomorrowStr;
            }
        }
        // Force refresh unavailable and unavailable zones when modal opens
        console.log('[Debug] openModal called, calling refresh functions...');
        
        setTimeout(() => {
            console.log('[Debug] Timeout executed, calling refresh functions...');
            console.log('[Debug] Calling refreshUnavailable...');
            refreshUnavailable();
            console.log('[Debug] Calling refreshUnavailableZones...');
            refreshUnavailableZones();
        }, 100); // Delay để đảm bảo modal đã render xong
    }

    // Hàm đóng modal
    function closeModal() {
        const modal = document.getElementById('bookingModal');
        modal.classList.add('hidden');
    }

    // Đóng modal khi nhấn ra ngoài nội dung modal
    document.getElementById('bookingModal').addEventListener('click', function (event) {
        if (event.target === this) {
            closeModal();
        }
    });

    // Validation form trước khi submit
    document.querySelector('#bookingModal form').addEventListener('submit', function(event) {
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        const zoneId = document.getElementById('zoneIdHidden').value;
        const preSelectedArea = parseInt(document.getElementById('preSelectedArea')?.value || '0');

        if (!startDate || !endDate) {
            event.preventDefault();
            alert('Vui lòng chọn đầy đủ ngày bắt đầu và ngày kết thúc.');
            return;
        }

        if (new Date(endDate) <= new Date(startDate)) {
            event.preventDefault();
            alert('Ngày kết thúc phải sau ngày bắt đầu.');
            return;
        }

        // Require either a zone selection or at least one 50 m² unit
        if (!zoneId && (!preSelectedArea || preSelectedArea <= 0)) {
            event.preventDefault();
            alert('Vui lòng chọn Zone hoặc chọn ít nhất 1 ô (50 m²).');
            return;
        }
    });
</script>
<script>
    function selectZone(el) {
        // Kiểm tra nếu zone đã được thanh toán (unavailable)
        if (el.classList.contains('zone-unavailable') || el.style.pointerEvents === 'none') {
            return; // Không cho phép chọn zone đã được thanh toán
        }
        
        // Toggle selection cho zone hiện tại
        el.classList.toggle('selected');
        
        // Lấy tất cả zone đã chọn
        var selectedZones = document.querySelectorAll('#zoneGrid .zone-tile.selected');
        var zoneIds = Array.from(selectedZones).map(function(zone) {
            return zone.getAttribute('data-zone-id');
        });
        
        // Cập nhật hidden inputs
        document.getElementById('zoneIdHidden').value = zoneIds.length > 0 ? zoneIds[0] : '';
        document.getElementById('zoneIdsHidden').value = zoneIds.join(',');
        
        // Bỏ chọn unit tiles nếu có zone được chọn
        if (zoneIds.length > 0) {
            document.querySelectorAll('#unitGrid .unit-tile.selected').forEach(function (tile) {
                tile.classList.remove('selected');
            });
            // Cập nhật số lượng unit đã chọn về 0
            if (typeof updateUnitSelectionCount === 'function') {
                updateUnitSelectionCount();
            }
        }
        
        // Cập nhật chi phí dự kiến
        if (typeof calculateEstimatedCost === 'function') {
            calculateEstimatedCost();
        }
    };
</script>
</body>
</html>