<!DOCTYPE html>
<html lang="vi" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Danh s√°ch kho</title>
    <link rel="stylesheet" th:href="@{/css/storage-list.css}">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* General Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f4f7fa;
            color: #333;
        }

        .page-wrapper {
            max-width: 1900px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Hero Section */
        .hero-section {
            color: white;
            padding: 60px 20px;
            border-radius: 12px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .hero-content h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .hero-content p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        /* Container */
        .container {
            padding: 20px;
        }

        /* Search Section */
        .search-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        .search-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            align-items: end;
        }

        .form-group {
            margin: 0;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #444;
        }

        .form-input, .form-select {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.3);
        }

        .input-with-icon {
            position: relative;
        }

        .search-indicator {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.9rem;
            color: #666;
        }

        /* Controls Section */
        .controls-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .sort-controls, .page-size-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sort-controls label, .page-size-controls label {
            font-weight: 600;
            color: #444;
        }

        /* Results Info */
        .results-info {
            margin-bottom: 20px;
            font-size: 1rem;
            color: #555;
            text-align: center;
        }

        /* Storage Grid */
        .storage-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
        }

        .storage-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .storage-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #f8f9fa;
        }

        .storage-name {
            font-size: 1.3rem;
            font-weight: 600;
            color: #333;
        }

        .status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .status-available {
            background: #e6f4ea;
            color: #28a745;
        }

        .status-rented {
            background: #f8d7da;
            color: #dc3545;
        }

        .card-content {
            padding: 20px;
        }

        .storage-info .info-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 1rem;
            color: #555;
        }

        .card-footer {
            padding: 15px 20px;
            display: flex;
            gap: 10px;
            justify-content: space-between;
            border-top: 1px solid #eee;
        }

        /* Button Styles */
        .btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            border: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, #007bff, #00c4ff);
            color: white;
            box-shadow: 0 2px 6px rgba(0, 123, 255, 0.3);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #0056b3, #0096cc);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.5);
            transform: translateY(-2px);
        }

        .btn-wishlist {
            background: #f1f3f5;
            color: #333;
            border: 1px solid #ddd;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .btn-wishlist:hover {
            background: #e9ecef;
            border-color: #ccc;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .btn-wishlist.in-wishlist {
            background: linear-gradient(135deg, #28a745, #34c759);
            color: white;
            border: none;
            box-shadow: 0 2px 6px rgba(40, 167, 69, 0.3);
        }

        .btn-wishlist.in-wishlist:hover {
            background: linear-gradient(135deg, #218838, #2ba84a);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.5);
            transform: translateY(-2px);
        }

        /* Pagination */
        .pagination-section {
            margin-top: 30px;
            text-align: center;
        }

        .pagination-nav {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .pagination {
            list-style: none;
            display: flex;
            gap: 8px;
        }

        .page-item {
            display: inline-block;
        }

        .page-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            border-radius: 8px;
            background: #fff;
            border: 1px solid #ddd;
            color: #007bff;
            text-decoration: none;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .page-link:hover {
            background: linear-gradient(135deg, #007bff, #00c4ff);
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.5);
            transform: translateY(-2px);
        }

        .page-item.active .page-link, .page-link.current {
            background: linear-gradient(135deg, #007bff, #00c4ff);
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.5);
            cursor: default;
        }

        .page-item.disabled .page-link {
            background: #f5f5f5;
            color: #aaa;
            border-color: #ddd;
            box-shadow: none;
            cursor: not-allowed;
        }

        /* No Results */
        .no-results {
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .no-results-icon {
            font-size: 2.5rem;
            color: #dc3545;
            margin-bottom: 15px;
        }

        .no-results h3 {
            font-size: 1.5rem;
            color: #333;
            margin-bottom: 10px;
        }

        .no-results p {
            color: #666;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
        }

        .toast.success {
            background: #28a745;
        }

        .toast.error {
            background: #dc3545;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .hero-content h1 {
                font-size: 1.8rem;
            }

            .search-grid {
                grid-template-columns: 1fr;
            }

            .controls-section {
                flex-direction: column;
                align-items: flex-start;
            }

            .storage-grid {
                grid-template-columns: 1fr;
            }

            .form-input, .form-select {
                width: 100%;
            }

            .card-footer {
                flex-direction: column;
                align-items: stretch;
            }

            .btn {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
<div class="page-wrapper">
    <!-- Navigation Bar -->
    <div th:replace="~{taskbar/customer-navbar :: customerNavbar}"></div>

    <!-- Hero Section -->
    <div class="hero-section">
        <div class="hero-content">
            <h1>T√¨m ki·∫øm kho l∆∞u tr·ªØ</h1>
            <p>H·ªá th·ªëng cho thu√™ kho h√†ng chuy√™n nghi·ªáp v·ªõi h∆°n 1000+ kho tr√™n to√†n qu·ªëc</p>
        </div>
    </div>

    <!-- Main Content -->
    <div class="container">
        <!-- Search Section -->
        <div class="search-section">
            <div class="search-card">
                <form method="get" th:action="@{/SWP/storages}" class="search-form" onsubmit="return false;">
                    <div class="search-grid">
                        <div class="form-group">
                            <label for="storageName">T√™n kho</label>
                            <div class="input-with-button">
                                <div class="input-with-icon">
                                    <input type="text"
                                           id="storageName"
                                           name="storageName"
                                           th:value="${searchStorageName}"
                                           placeholder="T√¨m theo t√™n kho..."
                                           class="form-input"
                                           oninput="performRealTimeSearchSafe(this)"
                                           onkeypress="handleEnterKey(event)"
                                           autocomplete="off">
                                    <div id="searchIndicator" class="search-indicator"></div>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="city">Th√†nh ph·ªë</label>
                            <div class="select-wrapper">
                                <select name="city" id="city" class="form-select" onchange="performRealTimeSearch()">
                                    <option value="">T·∫•t c·∫£ th√†nh ph·ªë</option>
                                    <option th:each="city : ${cities}"
                                            th:value="${city}"
                                            th:text="${city}"
                                            th:selected="${searchCity != null and searchCity.equals(city)}">
                                    </option>
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="status">Tr·∫°ng th√°i</label>
                            <div class="select-wrapper">
                                <select name="status" id="status" class="form-select" onchange="performRealTimeSearch()">
                                    <option value="">T·∫•t c·∫£ tr·∫°ng th√°i</option>
                                    <option value="true" th:selected="${searchStatus != null and searchStatus.equals('true')}">C√≤n tr·ªëng</option>
                                    <option value="false" th:selected="${searchStatus != null and searchStatus.equals('false')}">ƒêang thu√™</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
        </div>

        <!-- Results Section -->
        <div class="results-section">
            <!-- Sort and Pagination Controls -->
            <div class="controls-section">
                <div class="sort-controls">
                    <label for="sortBy">S·∫Øp x·∫øp theo:</label>
                    <select id="sortBy" name="sortBy" class="form-select" onchange="updateSort()">
                        <option value="storagename" th:selected="${sortBy == 'storagename'}">T√™n kho</option>
                    </select>
                    <select id="sortDir" name="sortDir" class="form-select" onchange="updateSort()">
                        <option value="asc" th:selected="${sortDir == 'asc'}">TƒÉng d·∫ßn</option>
                        <option value="desc" th:selected="${sortDir == 'desc'}">Gi·∫£m d·∫ßn</option>
                    </select>
                </div>
                <div class="page-size-controls">
                    <label for="pageSize">Hi·ªÉn th·ªã:</label>
                    <select id="pageSize" name="size" class="form-select" onchange="updatePageSize()">
                        <option value="6" th:selected="${size == 6}">6 kho/trang</option>
                        <option value="12" th:selected="${size == 12}">12 kho/trang</option>
                        <option value="24" th:selected="${size == 24}">24 kho/trang</option>
                        <option value="48" th:selected="${size == 48}">48 kho/trang</option>
                    </select>
                </div>
            </div>

            <!-- Results Info -->
            <div class="results-info">
                <span th:if="${totalElements > 0}">
                    Hi·ªÉn th·ªã [[${currentPage * size + 1}]] - [[${(currentPage + 1) * size > totalElements ? totalElements : (currentPage + 1) * size}]]
                    trong t·ªïng s·ªë [[${totalElements}]] kho
                </span>
                <span th:if="${totalElements == 0}">Kh√¥ng t√¨m th·∫•y kho n√†o</span>
            </div>

            <!-- Storage Grid -->
            <div class="storage-grid" id="storageGrid">
                <div class="storage-card" th:each="storage : ${storages}">
                    <div class="card-header">
                        <h3 class="storage-name" th:text="${storage.storagename}">T√™n kho</h3>
                        <div th:class="${storage.status} ? 'status-badge status-available' : 'status-badge status-rented'"
                             th:text="${storage.status} ? 'C√≤n tr·ªëng' : 'ƒêang thu√™'">
                            Tr·∫°ng th√°i
                        </div>
                    </div>
                    <div class="card-content">
                        <div class="storage-info">
                            <div class="info-item">
                                <i data-lucide="map-pin"></i>
                                <span th:text="${storage.address}">ƒê·ªãa ch·ªâ</span>
                            </div>
                        </div>
                    </div>
                    <div class="card-footer">
                        <a th:href="@{'/SWP/storages/' + ${storage.storageid}}" class="btn btn-primary">
                            <i data-lucide="eye"></i> Chi ti·∫øt
                        </a>
                        <button class="btn btn-wishlist btn-cart-icon">
                            <i data-lucide="shopping-cart"></i>
                        </button>

                    </div>
                </div>
            </div>

            <!-- No Results Message -->
            <div th:if="${storages.isEmpty()}" class="no-results">
                <div class="no-results-icon">
                    <i data-lucide="search-x"></i>
                </div>
                <h3>Kh√¥ng t√¨m th·∫•y kho n√†o</h3>
                <p>Th·ª≠ thay ƒë·ªïi b·ªô l·ªçc t√¨m ki·∫øm ƒë·ªÉ xem th√™m k·∫øt qu·∫£</p>
            </div>

            <!-- Pagination -->
            <div th:if="${totalPages > 1}" class="pagination-section">
                <nav class="pagination-nav">
                    <ul class="pagination">
                        <li th:class="${currentPage == 0} ? 'page-item disabled' : 'page-item'">
                            <a th:if="${currentPage > 0}"
                               th:href="@{/SWP/storages(page=${currentPage - 1}, size=${size}, sortBy=${sortBy}, sortDir=${sortDir}, storageName=${searchStorageName}, city=${searchCity}, status=${searchStatus})}"
                               class="page-link">
                                <i data-lucide="chevron-left"></i> Tr∆∞·ªõc
                            </a>
                            <span th:if="${currentPage == 0}" class="page-link disabled">
                                <i data-lucide="chevron-left"></i> Tr∆∞·ªõc
                            </span>
                        </li>
                        <li th:each="pageNum : ${#numbers.sequence(0, totalPages - 1)}"
                            th:if="${pageNum >= currentPage - 2 and pageNum <= currentPage + 2}"
                            th:class="${pageNum == currentPage} ? 'page-item active' : 'page-item'">
                            <a th:if="${pageNum != currentPage}"
                               th:href="@{/SWP/storages(page=${pageNum}, size=${size}, sortBy=${sortBy}, sortDir=${sortDir}, storageName=${searchStorageName}, city=${searchCity}, status=${searchStatus})}"
                               class="page-link" th:text="${pageNum + 1}">1</a>
                            <span th:if="${pageNum == currentPage}" class="page-link current" th:text="${pageNum + 1}">1</span>
                        </li>
                        <li th:class="${currentPage >= totalPages - 1} ? 'page-item disabled' : 'page-item'">
                            <a th:if="${currentPage < totalPages - 1}"
                               th:href="@{/SWP/storages(page=${currentPage + 1}, size=${size}, sortBy=${sortBy}, sortDir=${sortDir}, storageName=${searchStorageName}, city=${searchCity}, status=${searchStatus})}"
                               class="page-link">
                                Sau <i data-lucide="chevron-right"></i>
                            </a>
                            <span th:if="${currentPage >= totalPages - 1}" class="page-link disabled">
                                Sau <i data-lucide="chevron-right"></i>
                            </span>
                        </li>
                    </ul>
                </nav>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <div th:replace="~{taskbar/customer-footer :: customerFooter}"></div>
</div>

<script>
    lucide.createIcons();

    // Debug: Check if elements exist
    console.log('Page loaded, checking elements...');
    console.log('Storage grid:', document.getElementById('storageGrid'));
    console.log('Storage name input:', document.getElementById('storageName'));
    console.log('City select:', document.getElementById('city'));
    console.log('Status select:', document.getElementById('status'));

    const viewButtons = document.querySelectorAll('.view-btn');
    const storageGrid = document.getElementById('storageGrid');
    viewButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            viewButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const view = btn.dataset.view;
            storageGrid.className = view === 'list' ? 'storage-list' : 'storage-grid';
        });
    });
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            document.querySelector(this.getAttribute('href')).scrollIntoView({
                behavior: 'smooth'
            });
        });
    });

    // Real-time search functionality
    let searchTimeout;
    let lastSearchTerm = '';
    let lastResultCount = -1;
    let isSearching = false;

    function performRealTimeSearch() {
        // Clear previous timeout
        clearTimeout(searchTimeout);

        const storageName = document.getElementById('storageName').value;
        const city = document.getElementById('city').value;
        const status = document.getElementById('status').value;

        // Show search indicator immediately for text input
        const indicator = document.getElementById('searchIndicator');
        if (storageName && storageName.trim()) {
            indicator.textContent = 'üîç';
            indicator.classList.add('searching');
        } else {
            indicator.textContent = '';
            indicator.classList.remove('searching');
        }

        // Set new timeout to avoid too many requests
        searchTimeout = setTimeout(() => {
            // Prevent multiple simultaneous searches
            if (isSearching) {
                console.log('Search already in progress, skipping...');
                return;
            }

            // Build current search state
            const currentSearchTerm = storageName.trim();
            const currentCity = city.trim();
            const currentStatus = status.trim();
            const currentSearchState = `${currentSearchTerm}|${currentCity}|${currentStatus}`;

            // Check if search state actually changed
            const lastSearchState = `${lastSearchTerm}|${document.getElementById('city').dataset.lastValue || ''}|${document.getElementById('status').dataset.lastValue || ''}`;
            if (currentSearchState === lastSearchState) {
                console.log('Search state unchanged, skipping API call');
                return;
            }

            // Set searching flag
            isSearching = true;

            // Show loading indicator
            showSearchLoading(true);

            // Build query parameters
            const params = new URLSearchParams();
            if (currentSearchTerm) params.append('storageName', currentSearchTerm);
            if (currentCity) params.append('city', currentCity);
            if (currentStatus) params.append('status', currentStatus);

            // Make AJAX request
            console.log('Making search request to:', `/SWP/storages/search?${params.toString()}`);
            fetch(`/SWP/storages/search?${params.toString()}`)
                .then(response => {
                    console.log('Response status:', response.status);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text().then(text => {
                        console.log('Raw response:', text);
                        try {
                            return JSON.parse(text);
                        } catch (e) {
                            console.error('JSON parse error:', e);
                            console.error('Response text:', text);
                            throw new Error('Invalid JSON response from server');
                        }
                    });
                })
                .then(data => {
                    console.log('Search results:', data);

                    // Update the grid with results
                    updateStorageGrid(data);
                    updateResultCount(data.length);

                    // Update last search state
                    lastSearchTerm = currentSearchTerm;
                    lastResultCount = data.length;
                    document.getElementById('city').dataset.lastValue = currentCity;
                    document.getElementById('status').dataset.lastValue = currentStatus;

                    showSearchLoading(false);
                    isSearching = false; // Reset searching flag

                    // Update search indicator
                    if (currentSearchTerm) {
                        indicator.textContent = `${data.length} k·∫øt qu·∫£`;
                        indicator.classList.remove('searching');
                    } else {
                        indicator.textContent = '';
                        indicator.classList.remove('searching');
                    }
                })
                .catch(error => {
                    console.error('Search error:', error);
                    showSearchLoading(false);
                    isSearching = false; // Reset searching flag

                    // Try fallback form submission
                    console.log('AJAX failed, trying form submission fallback...');
                    fallbackSearch();

                    // Reset search indicator
                    indicator.textContent = '';
                    indicator.classList.remove('searching');
                });
        }, 200); // Wait 200ms after user stops typing for faster response
    }

    // Safe version that preserves focus
    function performRealTimeSearchSafe(inputElement) {
        // Store current cursor position
        const cursorPosition = inputElement.selectionStart;

        // Perform search immediately for better responsiveness
        performRealTimeSearch();

        // Restore focus and cursor position after a short delay
        setTimeout(() => {
            if (document.activeElement !== inputElement) {
                inputElement.focus();
                inputElement.setSelectionRange(cursorPosition, cursorPosition);
            }
        }, 10);
    }

    // Initialize page on load
    document.addEventListener('DOMContentLoaded', function() {
        console.log('Page loaded, initializing...');

        // Focus on search input for better user experience
        const searchInput = document.getElementById('storageName');
        if (searchInput) {
            searchInput.focus();
        }

        // Prevent form submission for real-time search
        const searchForm = document.querySelector('.search-form');
        if (searchForm) {
            searchForm.addEventListener('submit', function(e) {
                e.preventDefault();
                console.log('Form submission prevented - using AJAX search instead');
                performRealTimeSearch();
                return false;
            });
        }

        // Only perform initial search if there are no storages displayed
        const storageGrid = document.getElementById('storageGrid');
        const existingCards = storageGrid ? storageGrid.querySelectorAll('.storage-card') : [];

        if (existingCards.length === 0) {
            console.log('No storages displayed, performing initial search...');
            setTimeout(() => {
                performRealTimeSearch();
            }, 300);
        } else {
            console.log('Storages already displayed, skipping initial search');
        }
    });

    // Simple test function for button
    function testSearch() {
        console.log('Test search button clicked');
        const input = document.getElementById('storageName');
        if (input) {
            input.value = 'test';
            input.focus();
            // Trigger input event to activate real-time search
            input.dispatchEvent(new Event('input', { bubbles: true }));
        }
    }

    // Handle Enter key press for immediate search
    function handleEnterKey(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            event.stopPropagation();

            // Clear timeout to perform immediate search
            clearTimeout(searchTimeout);
            performRealTimeSearch();

            // Keep focus on input
            event.target.focus();
            return false;
        }
    }

    // Fallback: if AJAX fails, show error message instead of form submission
    function fallbackSearch() {
        console.log('AJAX search failed, showing error message');
        const storageGrid = document.getElementById('storageGrid');
        if (storageGrid) {
            storageGrid.innerHTML = `
                <div class="no-results" style="grid-column: 1 / -1; text-align: center; padding: 40px;">
                    <div class="no-results-icon">
                        <i data-lucide="wifi-off"></i>
                    </div>
                    <h3>L·ªói k·∫øt n·ªëi</h3>
                    <p>Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu. Vui l√≤ng th·ª≠ l·∫°i sau.</p>
                    <button onclick="location.reload()" class="btn btn-primary" style="margin-top: 10px;">
                        T·∫£i l·∫°i trang
                    </button>
                </div>
            `;
            // Re-create icons after updating innerHTML
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }
    }

    function updateStorageGrid(storages) {
        console.log('Updating storage grid with:', storages.length, 'storages');

        const storageGrid = document.getElementById('storageGrid');
        if (!storageGrid) {
            console.error('Storage grid element not found!');
            return;
        }

        // Save current focus element and cursor position
        const activeElement = document.activeElement;
        const isInputFocused = activeElement && activeElement.id === 'storageName';
        let cursorPosition = 0;
        if (isInputFocused) {
            cursorPosition = activeElement.selectionStart;
        }

        if (storages.length === 0) {
            storageGrid.innerHTML = `
                <div class="no-results" style="grid-column: 1 / -1; text-align: center; padding: 40px;">
                    <div class="no-results-icon">
                        <i data-lucide="search-x"></i>
                    </div>
                    <h3>Kh√¥ng t√¨m th·∫•y kho n√†o</h3>
                    <p>Th·ª≠ thay ƒë·ªïi t·ª´ kh√≥a t√¨m ki·∫øm ƒë·ªÉ xem th√™m k·∫øt qu·∫£</p>
                </div>
            `;
        } else {
            storageGrid.innerHTML = storages.map(storage => {
                return `
                <div class="storage-card">
                    <div class="card-header">
                        <h3 class="storage-name">${storage.storagename || 'T√™n kho'}</h3>
                        <div class="${storage.status ? 'status-badge status-available' : 'status-badge status-rented'}">
                            ${storage.status ? 'C√≤n tr·ªëng' : 'ƒêang thu√™'}
                        </div>
                    </div>
                    <div class="card-content">
                        <div class="storage-info">
                            <div class="info-item">
                                <i data-lucide="map-pin"></i>
                                <span>${storage.address || 'ƒê·ªãa ch·ªâ'}</span>
                            </div>
                        </div>
                    </div>
                    <div class="card-footer">
                        <a href="/SWP/storages/${storage.storageid}" class="btn btn-primary">
                            <i data-lucide="eye"></i> Chi ti·∫øt
                        </a>
                        <button class="btn btn-wishlist btn-cart-icon"
                                data-storage-id="${storage.storageid}"
                                onclick="toggleWishlist(this)">
                            <i data-lucide="shopping-cart"></i>
                        </button>
                    </div>
                </div>
                `;
            }).join('');
        }

        // Re-initialize Lucide icons first
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
            console.log('Lucide icons created');
        }

        // Then update wishlist UI (this will call lucide.createIcons() again)
        updateWishlistUI();
        console.log('Wishlist UI updated');

        // Restore focus and cursor position
        if (isInputFocused) {
            const inputElement = document.getElementById('storageName');
            if (inputElement) {
                inputElement.focus();
                inputElement.setSelectionRange(cursorPosition, cursorPosition);
            }
        }
    }

    function updateResultCount(count) {
        const countElement = document.querySelector('.results-info .count');
        if (countElement) {
            countElement.textContent = count;
        }
    }

    function showSearchLoading(show) {
        const storageGrid = document.getElementById('storageGrid');
        if (show) {
            storageGrid.style.opacity = '0.6';
            storageGrid.style.pointerEvents = 'none';
        } else {
            storageGrid.style.opacity = '1';
            storageGrid.style.pointerEvents = 'auto';
        }
    }

    // Pagination and sorting functions
    function updateSort() {
        const sortBy = document.getElementById('sortBy').value;
        const sortDir = document.getElementById('sortDir').value;
        const storageName = document.getElementById('storageName').value;
        const city = document.getElementById('city').value;
        const status = document.getElementById('status').value;
        const size = document.getElementById('pageSize').value;

        const params = new URLSearchParams();
        params.append('page', '0'); // Reset to first page when sorting
        params.append('size', size);
        params.append('sortBy', sortBy);
        params.append('sortDir', sortDir);
        if (storageName) params.append('storageName', storageName);
        if (city) params.append('city', city);
        if (status) params.append('status', status);

        window.location.href = `/SWP/storages?${params.toString()}`;
    }

    function updatePageSize() {
        const size = document.getElementById('pageSize').value;
        const sortBy = document.getElementById('sortBy').value;
        const sortDir = document.getElementById('sortDir').value;
        const storageName = document.getElementById('storageName').value;
        const city = document.getElementById('city').value;
        const status = document.getElementById('status').value;

        const params = new URLSearchParams();
        params.append('page', '0'); // Reset to first page when changing page size
        params.append('size', size);
        params.append('sortBy', sortBy);
        params.append('sortDir', sortDir);
        if (storageName) params.append('storageName', storageName);
        if (city) params.append('city', city);
        if (status) params.append('status', status);

        window.location.href = `/SWP/storages?${params.toString()}`;
    }

    // Check if wishlistItems already exists to avoid redeclaration
    if (typeof wishlistItems === 'undefined') {
        var wishlistItems = new Set();
    }
    document.addEventListener('DOMContentLoaded', function() {
        loadWishlist();
    });
    async function loadWishlist() {
        try {
            const response = await fetch('/api/wishlist/my');
            if (response.ok) {
                const wishlist = await response.json();
                wishlistItems.clear();
                wishlist.forEach(item => {
                    if (item.storage && item.storage.storageid) {
                        wishlistItems.add(item.storage.storageid);
                    }
                });
                updateWishlistUI();
                updateCartCount();
            } else if (response.status === 401) {
                console.log('User not logged in');
                updateCartCount();
            }
        } catch (error) {
            console.log('Error loading wishlist:', error);
            updateCartCount();
        }
    }
    async function toggleWishlist(button) {
        const storageId = parseInt(button.getAttribute('data-storage-id'));
        const isInWishlist = wishlistItems.has(storageId);
        try {
            const url = isInWishlist ? '/api/wishlist/remove' : '/api/wishlist/add';
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ storageId })
            });
            if (response.ok) {
                if (isInWishlist) {
                    wishlistItems.delete(storageId);
                    showToast('ƒê√£ x√≥a kh·ªèi wishlist!', 'success');
                } else {
                    wishlistItems.add(storageId);
                    showToast('ƒê√£ th√™m v√†o wishlist!', 'success');
                }
                updateWishlistUI();
                updateCartCount();
            } else {
                const errorText = await response.text();
                showToast(errorText || 'C√≥ l·ªói x·∫£y ra!', 'error');
            }
        } catch (error) {
            showToast('C√≥ l·ªói x·∫£y ra!', 'error');
            console.error('Error:', error);
        } finally {
            button.disabled = false;
        }
    }
    function updateWishlistUI() {
        const wishlistButtons = document.querySelectorAll('.btn-wishlist');
        console.log('Found', wishlistButtons.length, 'wishlist buttons');
        console.log('Wishlist items:', wishlistItems);

        wishlistButtons.forEach(button => {
            const storageId = parseInt(button.getAttribute('data-storage-id'));
            if (wishlistItems.has(storageId)) {
                button.classList.add('in-wishlist');
                button.innerHTML = '<i data-lucide="check"></i>';
                console.log('Storage', storageId, 'is in wishlist');
            } else {
                button.classList.remove('in-wishlist');
                button.innerHTML = '<i data-lucide="shopping-cart"></i>';
                console.log('Storage', storageId, 'is NOT in wishlist');
            }
        });

        // Re-create icons after updating innerHTML
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
            console.log('Lucide icons recreated in updateWishlistUI');
        }
    }
    function updateCartCount() {
        const count = wishlistItems.size;
        const cartCountElement = document.getElementById('cartCount');
        if (cartCountElement) {
            cartCountElement.textContent = count;
            cartCountElement.style.display = count === 0 ? 'none' : 'flex';
        }
    }
    function goToWishlist() {
        try {
            window.location.href = '/SWP/wishlist';
        } catch (error) {
            console.error('Error navigating to wishlist:', error);
            showToast('C√≥ l·ªói khi chuy·ªÉn trang!', 'error');
        }
    }
    function showToast(message, type = 'success') {
        const toast = document.getElementById('toast');
        if (toast) {
            toast.textContent = message;
            toast.className = 'toast ' + type;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
    }
</script>
<div id="toast" class="toast"></div>
</body>
</html>