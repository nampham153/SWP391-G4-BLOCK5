<!DOCTYPE html>
<html lang="vi" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Danh s√°ch kho</title>
    <link rel="stylesheet" th:href="@{/css/storage-list.css}">
    <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
<div class="page-wrapper">
    <!-- Navigation Bar -->
    <div th:replace="taskbar/customer-navbar :: customerNavbar"></div>

    <!-- Hero Section -->
    <div class="hero-section">
        <div class="hero-content">
            <h1>T√¨m ki·∫øm kho l∆∞u tr·ªØ</h1>
            <p>H·ªá th·ªëng cho thu√™ kho h√†ng chuy√™n nghi·ªáp v·ªõi h∆°n 1000+ kho tr√™n to√†n qu·ªëc</p>
        </div>
    </div>

    <!-- Main Content -->
    <div class="container">
        <!-- Search Section -->
        <div class="search-section">
            <div class="search-card">
                <form method="get" th:action="@{/SWP/storages}" class="search-form" onsubmit="return false;">
                    <div class="search-grid">
                        <div class="form-group" style="margin-left: 20px">
                            <label for="storageName">T√™n kho</label>
                            <div class="input-with-button">
                                <div class="input-with-icon" style="position: relative;">
                                    <input type="text"
                                           id="storageName"
                                           name="storageName"
                                           th:value="${searchStorageName}"
                                           placeholder="T√¨m theo t√™n kho ho·∫∑c ƒë·ªãa ch·ªâ..."
                                           class="form-input"
                                           style="width: 400px; padding-right: 40px;"
                                           oninput="performRealTimeSearchSafe(this)"
                                           onkeypress="handleEnterKey(event)"
                                           autocomplete="off">
                                    <div id="searchIndicator" class="search-indicator"></div>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="city">Th√†nh ph·ªë</label>
                            <div class="select-wrapper" style=" width: 300px;">
                                <select name="city" id="city" class="form-select" onchange="performRealTimeSearch()">
                                    <option value="">T·∫•t c·∫£ th√†nh ph·ªë</option>
                                    <option th:each="city : ${cities}"
                                            th:value="${city}"
                                            th:text="${city}"
                                            th:selected="${searchCity != null and searchCity.equals(city)}">
                                    </option>
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="status">Tr·∫°ng th√°i</label>
                            <div class="select-with-button" style="width: 800px;">
                                <div class="select-wrapper">
                                    <select name="status" id="status" class="form-select" onchange="performRealTimeSearch()">
                                        <option value="">T·∫•t c·∫£ tr·∫°ng th√°i</option>
                                        <option value="true" th:selected="${searchStatus != null and searchStatus.equals('true')}">C√≤n tr·ªëng</option>
                                        <option value="false" th:selected="${searchStatus != null and searchStatus.equals('false')}">ƒêang thu√™</option>
                                    </select>
                                </div>
                                

                            </div>
                        </div>
                    </div>
                </form>
            </div>
        </div>

        <!-- Results Section -->
        <div class="results-section">
            <div class="results-header">
                <div class="results-info">
                    <h2>T√¨m th·∫•y <span class="count" th:text="${storages.size()}">0</span> kho</h2>
                </div>
            </div>

            <!-- Storage Grid -->
            <div class="storage-grid" id="storageGrid">
                <div class="storage-card" th:each="storage : ${storages}">
                    <div class="card-header">
                        <h3 class="storage-name" th:text="${storage.storagename}">T√™n kho</h3>
                        <div th:class="${storage.status} ? 'status-badge status-available' : 'status-badge status-rented'"
                             th:text="${storage.status} ? 'C√≤n tr·ªëng' : 'ƒêang thu√™'">
                            Tr·∫°ng th√°i
                        </div>
                    </div>
                    <div class="card-content">
                        <div class="storage-info">
                            <div class="info-item">
                                <i data-lucide="map-pin"></i>
                                <span th:text="${storage.address}">ƒê·ªãa ch·ªâ</span>
                            </div>
                        </div>
                    </div>
                    <div class="card-footer">
                        <a th:href="@{'/SWP/storages/' + ${storage.storageid}}" class="btn btn-primary" style="width: 190px">
                            <i data-lucide="eye"></i>
                            Chi ti·∫øt
                        </a>
                        <button class="btn btn-wishlist btn-cart-icon"
                                th:attr="data-storage-id=${storage.storageid}"
                                onclick="toggleWishlist(this)"
                                style="width: 120px;">
                            <i data-lucide="shopping-cart"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- No Results Message -->
            <div th:if="${storages.isEmpty()}" class="no-results">
                <div class="no-results-icon">
                    <i data-lucide="search-x"></i>
                </div>
                <h3>Kh√¥ng t√¨m th·∫•y kho n√†o</h3>
                <p>Th·ª≠ thay ƒë·ªïi b·ªô l·ªçc t√¨m ki·∫øm ƒë·ªÉ xem th√™m k·∫øt qu·∫£</p>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <div th:replace="taskbar/customer-footer :: customerFooter"></div>
</div>

<script>
    lucide.createIcons();

    // Debug: Check if elements exist
    console.log('Page loaded, checking elements...');
    console.log('Storage grid:', document.getElementById('storageGrid'));
    console.log('Storage name input:', document.getElementById('storageName'));
    console.log('City select:', document.getElementById('city'));
    console.log('Status select:', document.getElementById('status'));

    const viewButtons = document.querySelectorAll('.view-btn');
    const storageGrid = document.getElementById('storageGrid');
    viewButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            viewButtons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const view = btn.dataset.view;
            storageGrid.className = view === 'list' ? 'storage-list' : 'storage-grid';
        });
    });
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            e.preventDefault();
            document.querySelector(this.getAttribute('href')).scrollIntoView({
                behavior: 'smooth'
            });
        });
    });

    // Real-time search functionality
    let searchTimeout;
    let lastSearchTerm = '';
    let lastResultCount = -1;
    let isSearching = false;

    function performRealTimeSearch() {
        // Clear previous timeout
        clearTimeout(searchTimeout);

        const storageName = document.getElementById('storageName').value;
        const city = document.getElementById('city').value;
        const status = document.getElementById('status').value;

        // Show search indicator immediately for text input
        const indicator = document.getElementById('searchIndicator');
        if (storageName && storageName.trim()) {
            indicator.textContent = 'üîç';
            indicator.classList.add('searching');
        } else {
            indicator.textContent = '';
            indicator.classList.remove('searching');
        }

        // Set new timeout to avoid too many requests
        searchTimeout = setTimeout(() => {
            // Prevent multiple simultaneous searches
            if (isSearching) {
                console.log('Search already in progress, skipping...');
                return;
            }

            // Build current search state
            const currentSearchTerm = storageName.trim();
            const currentCity = city.trim();
            const currentStatus = status.trim();
            const currentSearchState = `${currentSearchTerm}|${currentCity}|${currentStatus}`;

            // Check if search state actually changed
            const lastSearchState = `${lastSearchTerm}|${document.getElementById('city').dataset.lastValue || ''}|${document.getElementById('status').dataset.lastValue || ''}`;
            if (currentSearchState === lastSearchState) {
                console.log('Search state unchanged, skipping API call');
                return;
            }

            // Set searching flag
            isSearching = true;

            // Show loading indicator
            showSearchLoading(true);

            // Build query parameters
            const params = new URLSearchParams();
            if (currentSearchTerm) params.append('storageName', currentSearchTerm);
            if (currentCity) params.append('city', currentCity);
            if (currentStatus) params.append('status', currentStatus);

            // Make AJAX request
            console.log('Making search request to:', `/SWP/storages/search?${params.toString()}`);
            fetch(`/SWP/storages/search?${params.toString()}`)
                .then(response => {
                    console.log('Response status:', response.status);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text().then(text => {
                        console.log('Raw response:', text);
                        try {
                            return JSON.parse(text);
                        } catch (e) {
                            console.error('JSON parse error:', e);
                            console.error('Response text:', text);
                            throw new Error('Invalid JSON response from server');
                        }
                    });
                })
                .then(data => {
                    console.log('Search results:', data);

                    // Update the grid with results
                    updateStorageGrid(data, currentSearchTerm);
                    updateResultCount(data.length);

                    // Update last search state
                    lastSearchTerm = currentSearchTerm;
                    lastResultCount = data.length;
                    document.getElementById('city').dataset.lastValue = currentCity;
                    document.getElementById('status').dataset.lastValue = currentStatus;

                    showSearchLoading(false);
                    isSearching = false; // Reset searching flag

                    // Update search indicator
                    if (currentSearchTerm) {
                        indicator.textContent = `${data.length} k·∫øt qu·∫£`;
                        indicator.classList.remove('searching');
                    } else {
                        indicator.textContent = '';
                        indicator.classList.remove('searching');
                    }
                })
                .catch(error => {
                    console.error('Search error:', error);
                    showSearchLoading(false);
                    isSearching = false; // Reset searching flag

                    // Try fallback form submission
                    console.log('AJAX failed, trying form submission fallback...');
                    fallbackSearch();

                    // Reset search indicator
                    indicator.textContent = '';
                    indicator.classList.remove('searching');
                });
        }, 200); // Wait 200ms after user stops typing for faster response
    }

    // Safe version that preserves focus
    function performRealTimeSearchSafe(inputElement) {
        // Store current cursor position
        const cursorPosition = inputElement.selectionStart;

        // Perform search immediately for better responsiveness
        performRealTimeSearch();

        // Restore focus and cursor position after a short delay
        setTimeout(() => {
            if (document.activeElement !== inputElement) {
                inputElement.focus();
                inputElement.setSelectionRange(cursorPosition, cursorPosition);
            }
        }, 10);
    }

    // Test function to check API (removed to prevent conflicts)

    // Initialize page on load
    document.addEventListener('DOMContentLoaded', function() {
        console.log('Page loaded, initializing...');

        // Focus on search input for better user experience
        const searchInput = document.getElementById('storageName');
        if (searchInput) {
            searchInput.focus();
        }

        // Prevent form submission for real-time search
        const searchForm = document.querySelector('.search-form');
        if (searchForm) {
            searchForm.addEventListener('submit', function(e) {
                e.preventDefault();
                console.log('Form submission prevented - using AJAX search instead');
                performRealTimeSearch();
                return false;
            });
        }

        // Only perform initial search if there are no storages displayed
        const storageGrid = document.getElementById('storageGrid');
        const existingCards = storageGrid ? storageGrid.querySelectorAll('.storage-card') : [];

        if (existingCards.length === 0) {
            console.log('No storages displayed, performing initial search...');
            setTimeout(() => {
                performRealTimeSearch();
            }, 300);
        } else {
            console.log('Storages already displayed, skipping initial search');
        }
    });

    // Simple test function for button
    function testSearch() {
        console.log('Test search button clicked');
        const input = document.getElementById('storageName');
        if (input) {
            input.value = 'test';
            input.focus();
            // Trigger input event to activate real-time search
            input.dispatchEvent(new Event('input', { bubbles: true }));
        }
    }

    // Handle Enter key press for immediate search
    function handleEnterKey(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            event.stopPropagation();

            // Clear timeout to perform immediate search
            clearTimeout(searchTimeout);
            performRealTimeSearch();

            // Keep focus on input
            event.target.focus();
            return false;
        }
    }

    // Fallback: if AJAX fails, show error message instead of form submission
    function fallbackSearch() {
        console.log('AJAX search failed, showing error message');
        const storageGrid = document.getElementById('storageGrid');
        if (storageGrid) {
            storageGrid.innerHTML = `
                <div class="no-results" style="grid-column: 1 / -1; text-align: center; padding: 40px;">
                    <div class="no-results-icon">
                        <i data-lucide="wifi-off"></i>
                    </div>
                    <h3>L·ªói k·∫øt n·ªëi</h3>
                    <p>Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu. Vui l√≤ng th·ª≠ l·∫°i sau.</p>
                    <button onclick="location.reload()" class="btn btn-primary" style="margin-top: 10px;">
                        T·∫£i l·∫°i trang
                    </button>
                </div>
            `;
            // Re-create icons after updating innerHTML
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }
    }

    function updateStorageGrid(storages, searchTerm = '') {
        console.log('Updating storage grid with:', storages.length, 'storages');
        console.log('Search term:', searchTerm);

        const storageGrid = document.getElementById('storageGrid');
        if (!storageGrid) {
            console.error('Storage grid element not found!');
            return;
        }

        // Save current focus element and cursor position
        const activeElement = document.activeElement;
        const isInputFocused = activeElement && activeElement.id === 'storageName';
        let cursorPosition = 0;
        if (isInputFocused) {
            cursorPosition = activeElement.selectionStart;
        }

        if (storages.length === 0) {
            storageGrid.innerHTML = `
                <div class="no-results" style="grid-column: 1 / -1; text-align: center; padding: 40px;">
                    <div class="no-results-icon">
                        <i data-lucide="search-x"></i>
                    </div>
                    <h3>Kh√¥ng t√¨m th·∫•y kho n√†o</h3>
                    <p>Th·ª≠ thay ƒë·ªïi t·ª´ kh√≥a t√¨m ki·∫øm ƒë·ªÉ xem th√™m k·∫øt qu·∫£</p>
                </div>
            `;
        } else {
            storageGrid.innerHTML = storages.map(storage => {
                // Highlight search term in storage name and address
                const highlightedName = highlightSearchTerm(storage.storagename || 'T√™n kho', searchTerm);
                const highlightedAddress = highlightSearchTerm(storage.address || 'ƒê·ªãa ch·ªâ', searchTerm);

                return `
                <div class="storage-card">
                    <div class="card-header">
                        <h3 class="storage-name">${highlightedName}</h3>
                        <div class="${storage.status ? 'status-badge status-available' : 'status-badge status-rented'}">
                            ${storage.status ? 'C√≤n tr·ªëng' : 'ƒêang thu√™'}
                        </div>
                    </div>
                    <div class="card-content">
                        <div class="storage-info">
                            <div class="info-item">
                                <i data-lucide="map-pin"></i>
                                <span>${highlightedAddress}</span>
                            </div>
                        </div>
                    </div>
                    <div class="card-footer">
                        <a href="/SWP/storages/${storage.storageid}" class="btn btn-primary" style="width: 190px">
                            <i data-lucide="eye"></i>
                            Chi ti·∫øt
                        </a>
                        <button class="btn btn-wishlist btn-cart-icon"
                                data-storage-id="${storage.storageid}"
                                onclick="toggleWishlist(this)"
                                style="width: 120px;">
                            <i data-lucide="shopping-cart"></i>
                        </button>
                    </div>
                </div>
                `;
            }).join('');
        }

        // Re-initialize Lucide icons
        lucide.createIcons();

        // Update wishlist UI
        updateWishlistUI();

        // Restore focus and cursor position
        if (isInputFocused) {
            const inputElement = document.getElementById('storageName');
            if (inputElement) {
                inputElement.focus();
                inputElement.setSelectionRange(cursorPosition, cursorPosition);
            }
        }
    }

    function highlightSearchTerm(text, searchTerm) {
        if (!searchTerm || !text) return text;

        const regex = new RegExp(`(${escapeRegExp(searchTerm)})`, 'gi');
        return text.replace(regex, '<span class="search-highlight">$1</span>');
    }

    function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function updateResultCount(count) {
        const countElement = document.querySelector('.results-info .count');
        if (countElement) {
            countElement.textContent = count;
        }
    }

    function showSearchLoading(show) {
        const storageGrid = document.getElementById('storageGrid');
        if (show) {
            storageGrid.style.opacity = '0.6';
            storageGrid.style.pointerEvents = 'none';
        } else {
            storageGrid.style.opacity = '1';
            storageGrid.style.pointerEvents = 'auto';
        }
    }
</script>
<div id="toast" class="toast"></div>
<script>
    // Check if wishlistItems already exists to avoid redeclaration
    if (typeof wishlistItems === 'undefined') {
        var wishlistItems = new Set();
    }
    document.addEventListener('DOMContentLoaded', function() {
        loadWishlist();
    });
    async function loadWishlist() {
        try {
            const response = await fetch('/api/wishlist/my');
            if (response.ok) {
                const wishlist = await response.json();
                wishlistItems.clear();
                wishlist.forEach(item => {
                    if (item.storage && item.storage.storageid) {
                        wishlistItems.add(item.storage.storageid);
                    }
                });
                updateWishlistUI();
                updateCartCount();
            } else if (response.status === 401) {
                console.log('User not logged in');
                updateCartCount();
            }
        } catch (error) {
            console.log('Error loading wishlist:', error);
            updateCartCount();
        }
    }
    async function toggleWishlist(button) {
        const storageId = parseInt(button.getAttribute('data-storage-id'));
        const isInWishlist = wishlistItems.has(storageId);
        try {
            const url = isInWishlist ? '/api/wishlist/remove' : '/api/wishlist/add';
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ storageId })
            });
            if (response.ok) {
                if (isInWishlist) {
                    wishlistItems.delete(storageId);
                    showToast('ƒê√£ x√≥a kh·ªèi wishlist!', 'success');
                } else {
                    wishlistItems.add(storageId);
                    showToast('ƒê√£ th√™m v√†o wishlist!', 'success');
                }
                updateWishlistUI();
                updateCartCount();
            } else {
                const errorText = await response.text();
                showToast(errorText || 'C√≥ l·ªói x·∫£y ra!', 'error');
            }
        } catch (error) {
            showToast('C√≥ l·ªói x·∫£y ra!', 'error');
            console.error('Error:', error);
        } finally {
            button.disabled = false;
        }
    }
    function updateWishlistUI() {
        document.querySelectorAll('.btn-wishlist').forEach(button => {
            const storageId = parseInt(button.getAttribute('data-storage-id'));
            if (wishlistItems.has(storageId)) {
                button.classList.add('in-wishlist');
                button.innerHTML = '<i data-lucide="check"></i>';
            } else {
                button.classList.remove('in-wishlist');
                button.innerHTML = '<i data-lucide="shopping-cart"></i>';
            }
        });
    }
    function updateCartCount() {
        const count = wishlistItems.size;
        const cartCountElement = document.getElementById('cartCount');
        if (cartCountElement) {
            cartCountElement.textContent = count;
            cartCountElement.style.display = count === 0 ? 'none' : 'flex';
        }
    }
    function goToWishlist() {
        try {
            window.location.href = '/SWP/wishlist';
        } catch (error) {
            console.error('Error navigating to wishlist:', error);
            showToast('C√≥ l·ªói khi chuy·ªÉn trang!', 'error');
        }
    }
    function showToast(message, type = 'success') {
        const toast = document.getElementById('toast');
        if (toast) {
            toast.textContent = message;
            toast.className = 'toast ' + type;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
    }
</script>
</body>
</html>